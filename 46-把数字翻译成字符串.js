/**
 * 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
 * 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
 * 提示：0 <= num < 2^31
 * 关键词：“多少种”。
 * 解法：回溯，动态规划。本题动态规划更优。
 * 三板斧：状态定义，状态转移，初始状态
 * 定义：dp[i] 表示以0-i位子串总共的翻译方法。注意dp[0]是虚拟的，代表0位，空串。返回：dp[n]
 * 转移：dp[i] = dp[i-1] + if ({i-1,i}合法) dp[i-2]
 * 初始：dp[0] = 1, dp[1] = 1
 */
var translateNum = function (num) {
	if (isNaN(num)) return // XXX 这个题不会出现num不是数字的“输入错误”，为了好习惯还是写一下。注意不要用!num判定，这会把合法输入0也判为非法
	str = num.toString()
	let dp = []
	;(dp[0] = 1), (dp[1] = 1)
	for (let i = 1; i < str.length; i++) {
		const pre = str[i - 1] * 10 + parseInt(str[i]) // XXX 运算有讲究。*10操作会把字符串转为数字；但不加parseInt()的话，数字+字符串=字符串，会出错。
		dp[i + 1] = dp[i] + (pre < 26 && pre > 9 ? dp[i - 1] : 0) // XXX 要>9，因为只可以把1解析为b，01不可以。
	}
	return dp[str.length]
}
